<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="generator" content="MarkBind 4.1.0">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
    <link rel="stylesheet" href="/2023/markbind/css/bootstrap.min.css">
    <link rel="stylesheet" href="/2023/markbind/fontawesome/css/all.min.css">
    <link rel="stylesheet" href="/2023/markbind/glyphicons/css/bootstrap-glyphicons.min.css">
    <link rel="stylesheet" href="/2023/markbind/css/octicons.css">
    <link rel="stylesheet" href="/2023/markbind/material-icons/material-icons.css">
    <link rel="stylesheet" href="/2023/markbind/css/codeblock-light.min.css"><link rel="stylesheet" href="/2023/markbind/css/markbind.min.css"><script src="/2023/markbind/js/polyfill.min.js"></script>
    <script src="/2023/markbind/js/vue.min.js"></script>
    <script src="/2023/markbind/js/markbind.min.js"></script>
    <script src="knowledge.page-vue-render.js"></script>
    <script src="/2023/markbind/js/jquery.min.js"></script><link rel="stylesheet" href="/2023/plugins/markbind-plugin-anchors/markbind-plugin-anchors.css"><link rel="stylesheet" href="/2023/plugins/markbind-plugin-tree/markbind-plugin-tree.css">
    
  <link rel="stylesheet" href="/2023/stylesheets/main.css">
<link rel="icon" href="/2023/favicon.ico"></head>
<script>
  const baseUrl = '/2023'
</script>
<body >
<div id="app" data-server-rendered="true"><header fixed=""><div placement="top" data-v-15113a2f><nav class="navbar navbar-expand-md d-print-none navbar-dark bg-primary" data-v-15113a2f><div class="container-fluid" data-v-15113a2f><div class="navbar-left" data-v-15113a2f><a href="/2023/index.html" title="Home" class="navbar-brand" data-v-15113a2f>CS3281&amp;2-2023/Students</a></div> <div class="navbar-default" data-v-15113a2f><ul class="navbar-nav me-auto mt-2 mt-lg-0" data-v-15113a2f> <li class="nav-link dropdown" data-v-2e98b3f0><a role="button" data-bs-toggle="dropdown" class="dropdown-toggle" data-v-2e98b3f0>CS3281</a> <ul class="dropdown-menu" data-v-2e98b3f0> <li data-v-2e98b3f0><a href="/2023/index.html" class="dropdown-item" data-v-2e98b3f0>Students</a></li> <li data-v-2e98b3f0><a href="/2023/students/knowledge.html" class="dropdown-item" data-v-2e98b3f0>Knowledge</a></li> <li data-v-2e98b3f0><a href="https://nus-cs3281.github.io/2023-dashboard/?search=&amp;sort=groupTitle&amp;sortWithin=title&amp;timeframe=commit&amp;mergegroup=&amp;groupSelect=groupByAuthors&amp;breakdown=false" class="dropdown-item" data-v-2e98b3f0>Code Dashboard</a></li></ul></li> <li class="nav-link dropdown" data-v-2e98b3f0><a role="button" data-bs-toggle="dropdown" class="dropdown-toggle" data-v-2e98b3f0>CS3282</a> <ul class="dropdown-menu" data-v-2e98b3f0> <li data-v-2e98b3f0><a href="/2023/cs3282-index.html" class="dropdown-item" data-v-2e98b3f0>Students</a></li> <li data-v-2e98b3f0><a href="/2023/students/talksSchedule.html" class="dropdown-item" data-v-2e98b3f0>Lightning Talks</a></li></ul></li> <li data-v-15113a2f><a href="/2023/instructions.html" class="nav-link" data-v-15113a2f>Instructions</a></li> <li data-v-15113a2f><a href="https://nus-cs3281.github.io/website/" class="nav-link" data-v-15113a2f>CS3281&amp;2 Website <span data-v-15113a2f><span aria-hidden="true" class="glyphicon glyphicon-share-alt" data-v-15113a2f></span></span></a></li></ul></div> <ul class="navbar-nav navbar-right" data-v-15113a2f><li data-v-15113a2f><a href="https://github.com/nus-cs3281/2023" class="nav-link" data-v-15113a2f><span data-v-15113a2f><span aria-hidden="true" class="fab fa-github" data-v-15113a2f></span></span></a></li></ul></div></nav> <div class="lower-navbar-container" style="display:none;" data-v-15113a2f><!----> <!----></div></div></header> <div id="flex-body"><div id="content-wrapper" class="fixed-header-padding"><h3 id="cypress"><span id="cypress" class="anchor"></span>Cypress<a href="#cypress" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>Cypress is a tool for testing anything that run in a web browser. It is fast and easy to use. It allows the user to write reliable tests. Cypress can cover unit tests, integration tests as well as end-to-end test. Cypress also records down all the states during test for easy debugging.</p> <p>I learned how to set up a new Cypress test, fetch the target value and add assertions by using the <a href="https://docs.cypress.io/guides/getting-started/writing-your-first-test">Official Cypress Documentation</a>. This was used in of one the PRs when I modify some frontend behaviours.</p> <p>I also learned about the best pratices as well as some common anti-patterns when writing Cypress tests. One issue was raised over the use of <code class="hljs inline no-lang">wait()</code> most of our Cypress tests. This is actually an anti-pattern as described in the guide. In short, the previous command will not resolve until a response is received (or timeout in a negative case). Therefore, there is no need to explicitly wait. The use of <code class="hljs inline no-lang">wait()</code> in the context only slows the the test unnecessarily. After removing the use of <code class="hljs inline no-lang">wait()</code>, the local test speed was reduced from an average of 135 seconds to 60 seconds, which is quite a significant improvement. For more details, please visit <a href="https://docs.cypress.io/guides/references/best-practices">Cypress Best Practice</a>.</p> <h3 id="migration-from-vue-2-to-vue-3"><span id="migration-from-vue-2-to-vue-3" class="anchor"></span>Migration from Vue 2 to Vue 3<a href="#migration-from-vue-2-to-vue-3" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>RepoSense uses Vue for frontend. The current Vue version used is Vue 2. Vue 3 was a major upgrade introduced in September 2020. It is a major revamp from Vue 2. It is faster, lighter and introduce better TypeScript support. Migrating to Vue 3 is inevitable from a long term perspective. However, with such a major upgrade, many of the exisiting sytanx are no longer supported/changed. This bring a lot of issue during migration. The <a href="https://v3.vuejs.org/guide/migration/introduction.html#breaking-changes">Vue 3 Guide</a> summarises the breaking changes.</p> <p>The migration process is also long and tedious. The <a href="https://v3.vuejs.org/guide/migration/migration-build.html#overview">Official Vue Migration Build</a> provides a clear path to upgrade. This is also the one that I am currently using to work on the migration.</p> <h3 id="vue-v-if-and-v-for"><span id="vue-v-if-and-v-for" class="anchor"></span>(Vue) <code class="hljs inline no-lang">v-if</code> and <code class="hljs inline no-lang">v-for</code><a href="#vue-v-if-and-v-for" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>In Vue 2, when using <code class="hljs inline no-lang">v-if</code> and <code class="hljs inline no-lang">v-for</code> on the same element, <code class="hljs inline no-lang">v-for</code> would take precedence. In Vue 3, <code class="hljs inline no-lang">v-if</code> will always have the higher precedence than <code class="hljs inline no-lang">v-for</code>. In the migration guide, it is stated that:</p> <pre><code class="hljs"><span>It is recommended to avoid using both on the same element due to the syntax ambiguity.
</span><span>
</span><span>Rather than managing this at the template level, one method for accomplishing this is to create a computed property that filters out a list for the visible elements.
</span></code></pre><p>This makes a lot of sense. When we mix if and for together, we might end up confusing ourselevs and introduce bugs that are diffifcult to catch. When we operate on a filtered list, there is no ambiguity is the code. Not only does this help us to avoid bugs, it also makes the code easier to read and easier for someone else to understand.</p> <h3 id="vue-v-if-vs-v-show"><span id="vue-v-if-vs-v-show" class="anchor"></span>(Vue) <code class="hljs inline no-lang">v-if</code> vs <code class="hljs inline no-lang">v-show</code><a href="#vue-v-if-vs-v-show" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p><code class="hljs inline no-lang">v-if</code> is a “real” conditional rendering as it is created/destroyed when the condition is true/false. <code class="hljs inline no-lang">v-if</code> is also lazy in the sense that the condition within the conditional block will only be rendered until the condition is true.</p> <p>On the other hand, <code class="hljs inline no-lang">v-show</code> always renders the element regardless of the initial condition. The visibility is controlled by the css.</p> <p>In general, <code class="hljs inline no-lang">v-if</code> has higher toggle cost because it needs to render the element when the condition is true. However, it can be used to save some initial loading time if it is false initially. <code class="hljs inline no-lang">v-show</code> might incur higher initial reader costs because everything is rendered on loading, but the toggling cost is very little. The general advice is that if you need to toggle the element very often, use <code class="hljs inline no-lang">v-show</code>. Use <code class="hljs inline no-lang">v-if</code> if the condition is unlikely to change during runtime.</p> <h3 id="vue-watchers"><span id="vue-watchers" class="anchor"></span>(Vue) Watchers<a href="#vue-watchers" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>Computed properties allow us to compute derived values declaratively. However, sometimes the values changes due to side effects of the program. Watchers allow us to trigger a function whenever a property changes.</p> <p>We often use watcher on an array property. In Vue 2, the watcher is triggered whenever something within the array changes. However, this is not the default setting in Vue 3. In Vue 3, the watcher will only be shallow. Meaning that it will only be triggered when the watcher property has been assigned a new value. Any inner value changes will not trigger the watcher to fire. This is likely due to performance optimisation. To enable watcher action on all nested mutation, we need to use a deep watcher. The following code snippet is an example.</p> <pre><code class="hljs"><span>watch: {
</span><span>    someObject: {
</span><span>        handler(newValue, oldValue) {
</span><span>            // action to take
</span><span>        },
</span><span>        deep: true // Needed in Vue 3 for mutation of nested values
</span><span>    }
</span><span>}
</span></code></pre><h3 id="checking-plugin-github-issue-page"><span id="checking-plugin-github-issue-page" class="anchor"></span>Checking Plugin GitHub Issue Page<a href="#checking-plugin-github-issue-page" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>When dealing with a plugin (debugging/upgrading), we sometimes face some unexplained behaviours. I spent hours debugging and searching for decumentation only to realise that it is a bug of the plugin. Always check the issue page of the plugin when in doubt, especially when it comes to compatibility issues after upgrading the plugin or other plugins.</p> <h3 id="opening-issues"><span id="opening-issues" class="anchor"></span>Opening Issues<a href="#opening-issues" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>When opening an issue, we should make the problem clear. We should explicitly state the difference and the expected behaviour so that anyone can understand the issue clearly. An unclear issue may lead to misunderstanding and lead to hours wasted on an unrelated work.</p> <h3 id="working-with-json-files"><span id="working-with-json-files" class="anchor"></span>Working with JSON files<a href="#working-with-json-files" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>Never put any comments in <code class="hljs inline no-lang">.json</code> files. Comments of the form <code class="hljs inline no-lang">//...</code> and <code class="hljs inline no-lang">/*...*/</code> are not allowed. Some IDEs do not flag out this as an error and such files might be able to be used normally. However, when error arises due to this issue, it is extremely difficult to find the error as the error message often do not point to the incorrect files.</p> <h3 id="class-style-component-syntax"><span id="class-style-component-syntax" class="anchor"></span>Class-style component syntax<a href="#class-style-component-syntax" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>I came across this term during the integration of Typescript to our project. In Vue, this means that the syntax will be <code class="hljs inline no-lang">export default class Counter extends Vue</code>. This is an alternative to the normal style we use. Some of the advantages includes the ability to utilize some ECMAScript language features such as class inheritance and decorators. For more details, please refer to <a href="https://class-component.vuejs.org">here</a>.</p> <h3 id="the-use-of-a-utility-class"><span id="the-use-of-a-utility-class" class="anchor"></span>The use of a utility class<a href="#the-use-of-a-utility-class" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>Some functions are used by many parts of the project. We might find it tempting to put everything in a utility class and make it accessible to everyone. However, this increases coupling and makes future debugs/updates extremely difficult. We should examine the consumers of the functions and group them in a sensible way. In stead of having a huge utility class, we can split it into smaller ones with clear responsibilities. This way we apply separation of concerns and we might not need to make the class global.</p> <h3 id="some-useful-typescript-syntax"><span id="some-useful-typescript-syntax" class="anchor"></span>Some useful typescript syntax<a href="#some-useful-typescript-syntax" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <ul><li>Optionals can be represented as <code class="hljs inline no-lang">?</code>. For example, <code class="hljs inline no-lang">age?: number</code> is equivalent to <code class="hljs inline no-lang">age: number | undefined</code> but it is much simpler to read and write.</li> <li>Arrays can be represented as <code class="hljs inline no-lang">Array&lt;T&gt;</code> or <code class="hljs inline no-lang">T[]</code>. I personally think that it is better to use the latter as it allows us to define an array of any complex objects.</li> <li>We can define our own type if it is used commonly. The <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces">syntax</a> is straightforward. However, take note of the <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces">Differences Between Type Aliases and Interfaces</a>.</li></ul> <i id="scroll-top-button" onclick="handleScrollTop()" aria-hidden="true" class="fa fa-arrow-circle-up fa-lg d-print-none"></i></div> <nav id="page-nav" class="fixed-header-padding" data-v-e8c82f88><div class="nav-component slim-scroll" data-v-e8c82f88></div> <!----></nav></div> <footer><div class="text-center"><p>[<strong>This site was generated using <img src="https://markbind.org/favicon.ico" width="25"> <a href="https://markbind.org/">MarkBind 4.1.0</a></strong> on Tue, May 2, 2023, 2:23:27 PM UTC]<br> <span class="dimmed"><small><small>favicon.ico of this site was made by <a href="https://www.flaticon.com/authors/smashicons" title="Smashicons">Smashicons</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a> is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></small></small></span></p></div></footer></div>
</body><script src="/2023/markbind/js/bootstrap-utility.min.js"></script>
<script>
  MarkBind.setupWithSearch()
</script>
</html>
