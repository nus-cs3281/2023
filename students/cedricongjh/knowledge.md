### Angular
## Context
Having worked on CATcher for IWM last summer, I've gained familiarity with Angular. Working on TEAMMATES, I've deepened my knowledge
of the framework, and there were two new things that I've picked up about Angular.

## Pipes
Although I was previously aware of the use of pipes, I was not aware of the performance aspect. In particular, using pipes
are much more efficient than methods to render strings:

```javascript
{% raw %}
<h1>{{ name.toLowerCase() }}</h1>

<h1>{{ name | lowercase }}</h1>
{% endraw %}
```

When using a method, it is always run whenever the component is detecting changes. However, for pipes, they are only run
when the input of the pipe, in this case `name`, is changed.

[Here](https://medium.com/angular-in-depth/tiny-angular-pipe-to-make-any-function-memoizable-f6c8fa917f2f) is a medium article that
dives more into the benefits of using pipes.

## Angular Template
ES6 template literals and nested string interpolation aren't supported in Angular:

```javascript
{% raw %}
<div>{{ `(${text})`) }}</div>
{% endraw %}
```

This was something that I learnt from an open source contributor in [this](https://github.com/TEAMMATES/teammates/pull/12249) PR.

### Hibernate
## Context
Prior to taking CS3281, I've only used Java in CS2030S, CS2040S and of course CS2103T, never on a live system used by actual users.
This was hence my first experience in writing a Java backend, and I'm glad that I got the opportunity, and I am confident that 
I'm now able to work on backend systems with Hibernate, from defining database tables, specifying entity relations, and writing queries.
The following are a few aspects of Hibernate I'd like to highlight.

## Entities
In Hibernate, each class created by the developer creates a corresponding table in the database. (with some exceptions, I'll get to that later) A typical Hibernate entity looks like this:

```java
@Entity
public class Class {
    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable=false)
    private String field;
}
```

There's quite alot going on here, so let's break it down:
- On top of normal Java classes, Hibernate uses annotations (preceded with '@') to denote properties of classes and class fields.
- The `@Entity` annotation identifies a class as an entity class, whose fields are to be persisted to the database.
- `@Id` specifies the primary key.
- `@GeneratedValue` is typically used for primary key columns, to denote that a field should be generated by the database upon object creation.
- `@Column` is an optional annotation that allows one to customise the mapping between the entity attribute and database column. In this case, `nullable=false` ensures that the database column `field` for the table `Class` cannot have non-null values.

A database table corresponding to the class will be created, with columns `id` and `field`.

There are numerous annotations, and Thorben Janssen's [guide](https://thorben-janssen.com/key-jpa-hibernate-annotations/) gives a in depth overview of the most essential ones.

## Entity lifecycle
Once the entities are defined, we can perform create, update and delete operations, and these effects will be persisted to the database.

For instance, when we have a `Student` class with a `name` field, and we would like to update it, we simply call the field's setter, `student.setName("newName");` to update the student's name. 

Hibernate will persist the changes to the database automatically, without the developer having to explicitly do so.

There's a great guide on the entity lifecycle [here](https://thorben-janssen.com/entity-lifecycle-model/)

## Inheritance
Inheritance is a key feature of OOP languages such as Java, and is also supported by Hibernate. 

There are a few different ways that inherited entities are mapped to database tables.

One of which is the `SingleTable` inheritance strategy.

As per its namesake, in `SingleTable` inheritance, all child classes are mapped to one table.

For example, the classes below,

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public class Class {
    @Id
    @GeneratedValue
    private Long id;
}

@Entity
public class ClassA extends Class {
    @Column
    private String description;
}

@Entity
public class ClassB extends Class {
    @Column
    private Integer quantity;
}
```

Will be mapped onto a single table, `Class`, with the fields `id`, `description` and `quantity`.

A drawback would be that we cannot enforce non-null constraints on any of the database columns, since for records of `ClassA`, they
would have the attribute `description` but not `quantity`, and for records of `ClassB`, they would not have the attribute `description`
but have `quantity`.

An advantage of `SingleTable` strategy compared to others is that there is no need for joins. For instance, in the `Joined Table` strategy,
each subclass will have its own table, and when querying, it is joined with the parent class' table. This was one of the reasons why
`SingleTable` inheritance was ultimately chosen for `FeedbackQuestion` and `FeedbackResponse` entities, as they had many subclasses.

Baeldung's [guide](https://www.baeldung.com/hibernate-inheritance) on inheritance strategies was extremely helpful to me in understanding the differences between them, and the tradeoffs one needs to consider when choosing among them.

### Testing

## Context
Prior to working on TEAMMATES, the only exposure to software testing I had was in CS2103T. Working on the migration to postgresql involved writing tests, and
through that I've gained a slightly better understanding of the different types of tests, and a much greater appreciation of the importance of tests. When 
migrating the system to postgres, having the old test cases provided us with some reassurance that the changes we made to the system would not impact the 
existing functionalities, which is absolutely essential for a live system.
## Unit vs Integration testing
Unit testing is testing individual components, in isolation. For components with dependancies, these dependancies are mocked to ensure that any errors
would be due to bugs in the component itself, and not its underlying dependancies. An example of this in TEAMMATES would be that when doing unit testing
for the logic layer, which depends on the database layer, we mock the database layer. 

Integration testing on the other hand, tests if the various components are working when combined together. Building upon the unit testing example, when doing 
integration testing for the logic layer, we would not mock the database layer, but rather have the database layer actually perform its operations.

Having both of these types of tests are necessary in a big system like TEAMMATES: unit testing gives us the reassurance that the invididual components
are working on its own, while integration testing ensures that they work together. With good unit testing, we can be certain that any issues in integration
testing is most likely due to the interaction between the components, rather than the component itself, making debugging easier. The tests together ensures that no
breaking changes are introduced to the system, and is thus essential in a live system like TEAMMATES.

[Here](https://www.softwaretestinghelp.com/the-difference-between-unit-integration-and-functional-testing/) is an article that summarises the differences between
unit testing, integration testing and 

### OOP patterns

## Builder pattern
The builder pattern is useful when a class has many fields that are optional upon instantiation.
Imagine a Java class that has 3 fields:

```java
public class Foo {
    String a;
    Integer b;
    Long c;
}
```

For this class, say that a, b and c are optional, and that they are not needed when creating a `Foo` object.
To cater for every combination, we would require many constructors:

```java
Foo(String a) {
    this.a = a;
}

Foo(String a, Integer b) {
    this.a = a;
    this.b = b;
}

Foo(String a, Integer b, Long c) {
    this.a = a;
    this.b = b;
    this.c = c;
}

```

And many more for the other combinations...

To solve this issue, we can make use of the builder pattern, creating a static builder class inside `Foo`:

```java

public static class FooBuilder() {
    public Foo setA(String a) {
        this.a = a;
        return this;
    }


    public Foo setB(Integer b) {
        this.b = b;
        return this;
    }

    public Foo setC(Long c) {
        this.c = c;
        return this;
    }

    public Foo build() {
        return new Foo(this);
    }
}

```

We can then create `Foo`, with a b or c being optional without having to create numerous constructors:

```java
Foo foo = new Foo.FooBuilder().setA("string").setC(100).build();
```

## Factory pattern
The factory pattern should be used when an object needs to be created, but the object to be created is dependant on criteria.
The creation logic should then be encapsulated in a factory method.

A simple example would be creation of `SomeClass` below:

```java
public abstract class SomeClass {
}

public class SomeClassA extends SomeClass {
    Integer a;
}

public class SomeClassB extends SomeClass {
    boolean b;
}
```

Say that `SomeClass` is required to be created, and whether we create `SomeClassA` or `SomeClassB` depends on an enum:

```java
enum Type {
    A,
    B
}

Type type = Type.A;
SomeClass someClass;

switch(type) {
case Type.A:
    someClass = new SomeClassA(1);
    break;
case Type.B:
    someClass = new SomeClassB(true);
    break;
default:
    break;
}
```

It would be much better to encapsulate this logic in `SomeClass`:

```java

public abstract class SomeClass {
    
    public static createSomeClass(Type type) {
        switch(type) {
        case Type.A:
            return new SomeClassA(1);
        case Type.B:
            return new SomeClassB(true);
        default:
            return null;
        }
    }
}

SomeClass someClass = SomeClass.createSomeClass(type);

```

This way, the creation logic is able to be reused throughout the application, and also any changes, such as adding a new subclass, can be more easily done,
allowing for more extensible code.
[Here](https://sergeyzhuk.me/2017/05/22/when-to-factory/) is a great article on why the factory method is useful.

### Misc

## Migrations
Observing how the migration from datastore to postgresql is carried out for a live system used by users worldwide, with no impact to them is pretty amazing to me.
Our dualDB approach, where we still query the datastore for courses that are not migrated yet, ensures that functionalities are still avaliabile for the users,
even when we make huge changes to the system. This is also known as a trickle migration.

[Here](https://www.talend.com/resources/understanding-data-migration-strategies-best-practices/) is an article I came across when searching up on
the types of migration strategies used.

## Github web editor
Credits to Samuel for this, but I was previously unaware that github had a web editor. By pressing `.` on PRs, it opens the web editor which is
extremely useful for reviewing PRs, especially those that make changes to large files, so that we can easily view the changes made with the context
of the entire file, and also its various dependencies.
## Git interactive rebase
I've learnt the use of interactive rebase, and how I can use it to rewrite my commit history. This is particularly useful when I would like to remove
commits that are unncesary (for instance commits like `fix checkstyle`), and create a more meaningful commit chain for my PRs. Although the commits are
squashed in the end when merged, I find that it is important especially for larger PRs to keep a meaningful commit history, to make it easier on reviewers.

[Here](https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase) is an article by atlassian that provides more details about the rebase command.

## Github CLI
Prior to this module, I've never used the github CLI, sticking with just `git` commands. However, I found it very useful to use the CLI, especially when reviewing
PRs, as it allowed me to checkout someone's branch with just one command, which github provides on the review page, rather than having to add their remote repo,
fetching their branches and then checking out the branch. 